# Lab №1: CLIENT-SERVER ARCHITECTURE
## Borisov Dmitriy 6133-010402D

## Задание
__Исходные данные__

• Цифровое изображение.

• Алгоритм внесения искажений.

__Общий план выполнения работы__
1. Разработать клиент серверный механизм передачи цифрового изображения.
2. Учесть возможность возникновения помех в канале передачи.
3. Разработать блок восстановления полученных изображений на стороне сервера.
4. Для передачи данных между клиентом и сервером использовать сокеты Беркли.
5. Оценить потери данных при наличии блока восстановления ошибок и при его отсутствии.

__Содержание отчета__
Отчет по работе должен содержать:

• код разработанного программного решения;

• входное и выходные изображения (с применением блока восстановления ошибок и без его использования).

В качестве алгоритма внесения искажений использовать __импульсный шум__ (salt and peper).

__Язык программирования__: любой (Python v3.9.1)

## Краткое Описание:

_ImageSender.py_ - класс, наследующий Thread библиотеки threading и описывающий передачу и приём изображения с помощью сокетов;

_CLient.py_ - класс клиента, наследующий ImageSender и отправляющий изображение через порт;

_Noise.py_ - класс шума, наследующий ImageSender и принимающий изображение от Client для добавления импульсного шума;

_Server.py_ - класс сервера, наследующий ImageSender и принимающий зашумленное и оригинальное изображение от Noise для восстановления и проверки;

_test.ipynb_ - __Jupiter Notebook с тестировкой работы клиент-серверной архитектуры;__

_original.jpg_ - оригинальное изображение;

_noise.jpg_ - зашумленное изображение (автоматически обновляется в ходе работы);

_result.jpg_ - восстановленное изображение (автоматически обновляется в ходе работы);

## Подробное описание:

Архитектура приложения представлена в виде взаимодействия трёх модулей Client-Noise-Server:

•	Client – модуль клиента, отправляющий изображение по порту 55555;

•	Noise – модуль импульсного шума, принимающий изображение от клиента по порту 55555 и передающий серверу по порту 55556 исходное и зашумлённое изображение;

•	Server – модуль сервера, принимающий по порту 55556 изображения, восстанавливающий зашумлённое изображение медианным размытием библиотеки cv2 и проводящее оценку качества между исходным изображением и зашумлённым и восстановленным изображениями.

Передача изображений осуществляется по частям (блоками 1024 байта) с помощью сокетов из библиотеки socket через IP адрес хоста 127.0.0.1.

Исходное изображение размером 1280x720, его зашумлённая изображение импульсным шумом (salt and peper) и восстановленное изображение медианным размытием представлены ниже. 

Для оценки качества изображений использовались метрики среднего абсолютного отклонения и среднеквадратичного отклонения цвета пикселей. Результаты оценки качества полученных изображений приведены в таблице 1.
Таблица 1 – Оценка качества полученных изображений с исходным
<table border="0" cellpadding="0" cellspacing="0" id="sheet0" class="sheet0 gridlines">
    <col class="col0">
    <col class="col1">
    <col class="col2">
    <tbody>
      <tr class="row0">
        <td class="column0 style1 null"></td>
        <td class="column1 style2 s">Среднее абсолютное отклонение</td>
        <td class="column2 style2 s">Среднеквадратичное отклонение</td>
      </tr>
      <tr class="row1">
        <td class="column0 style3 s">Зашумлённое изображение</td>
        <td class="column1 style4 n">15.39</td>
        <td class="column2 style4 n">3218.03</td>
      </tr>
      <tr class="row2">
        <td class="column0 style3 s">Восстановленное изображение</td>
        <td class="column1 style4 n">49.4</td>
        <td class="column2 style4 n">11660.52</td>
      </tr>
    </tbody>
</table>

Реализован алгоритм наложения импульсного шума с последовательным прохождением по каждому пикселю с вероятностью 0,1 наложения на него белого или чёрного цвета. В дальнейшем этот алгоритм можно оптимизировать параллельной обработкой каждого пикселя с помощью CUDA в библиотеке numba или pycuda языка программирования Python. Использование данных библиотек на примерах векторного сложения, матричного умножения, вычисления числа Пи и массового поиска подстрок представлено в моём репозитории по [высокопроизводительным вычислениям](https://github.com/DiBoS290699/High-Performance_Computing). Опыты в данном репозитории указывают на значительный рост производительности с большими данными, а значит параллельная обработка каждого пикселя изображения в высоком разрешении может в разы увеличить производительность.

Для восстановления изображения применялся медианный фильтр библиотеки cv2 языка программирования Python, благодаря которому можно избавиться от импульсного шума, но испортить часть данных из-за размытия.


## Изображения

_Исходное изображение_

![Оригинальное изображение](./original.jpg)

_Зашумлённое изображение_

![Зашумлённое изображение](./noise.jpg)

_Восстановленное изображение_

![Восстановленное изображение](./result.jpg)


