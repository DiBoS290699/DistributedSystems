# Lab №1: CLIENT-SERVER ARCHITECTURE
## Borisov Dmitriy 6133-010402D

## Задание
__Исходные данные__

• Цифровое изображение.

• Алгоритм внесения искажений.

__Общий план выполнения работы__
1. Разработать клиент серверный механизм передачи цифрового изображения.
2. Учесть возможность возникновения помех в канале передачи.
3. Разработать блок восстановления полученных изображений на стороне сервера.
4. Для передачи данных между клиентом и сервером использовать сокеты Беркли.
5. Оценить потери данных при наличии блока восстановления ошибок и при его отсутствии.

__Содержание отчета__
Отчет по работе должен содержать:

• код разработанного программного решения;

• входное и выходные изображения (с применением блока восстановления ошибок и без его использования).

В качестве алгоритма внесения искажений использовать __импульсный шум__ (salt and peper).

__Язык программирования__: любой (Python v3.9.1)

## Краткое Описание:

_ImageSender.py_ - класс, наследующий Thread библиотеки threading и описывающий передачу и приём изображения с помощью сокетов;

_CLient.py_ - класс клиента, наследующий ImageSender и отправляющий изображение через порт;

_Noise.py_ - класс шума, наследующий ImageSender и принимающий изображение от Client для добавления импульсного шума;

_Server.py_ - класс сервера, наследующий ImageSender и принимающий зашумленное и оригинальное изображение от Noise для восстановления и проверки;

_test.ipynb_ - __Jupiter Notebook с тестировкой работы клиент-серверной архитектуры;__

_original.jpg_ - оригинальное изображение;

_noise.jpg_ - зашумленное изображение (автоматически обновляется в ходе работы);

_result.jpg_ - восстановленное изображение (автоматически обновляется в ходе работы);

## Подробное описание:

Архитектура приложения представлена в виде взаимодействия трёх модулей Client-Noise-Server:

•	Client – модуль клиента, отправляющий изображение по порту 55555;

•	Noise – модуль импульсного шума, принимающий изображение от клиента по порту 55555 и передающий серверу по порту 55556 исходное и зашумлённое изображение;

•	Server – модуль сервера, принимающий по порту 55556 изображения, восстанавливающий зашумлённое изображение медианным размытием библиотеки cv2 и проводящее оценку качества между исходным изображением и зашумлённым и восстановленным изображениями.

Передача изображений осуществляется по частям (блоками 1024 байта) с помощью сокетов из библиотеки socket через IP адрес хоста 127.0.0.1.

Исходное изображение размером 1280x720, его зашумлённая изображение импульсным шумом (salt and peper) двумя реализациями и восстановленное изображение медианным размытием после использования двух реализаций шума представлены ниже. 

Для оценки качества изображений использовались метрики среднего абсолютного отклонения и среднеквадратичного отклонения цвета пикселей. Результаты оценки качества полученных изображений приведены в таблице 1.
Таблица 1 – Оценка качества полученных изображений с исходным
<table border="0" cellpadding="0" cellspacing="0" id="sheet0" class="sheet0 gridlines">
    <col class="col0">
    <col class="col1">
    <col class="col2">
    <col class="col3">
    <col class="col4">
    <col class="col5">
    <col class="col6">
    <tbody>
      <tr class="row0">
        <td class="column0 style3 null"></td>
        <td class="column1 style8 s style14" colspan="2">Зашумлённое изображение</td>
        <td class="column3 style11 s style12" colspan="2">Восстановленное изображение</td>
        <td class="column5 style6 null"></td>
      </tr>
      <tr class="row1">
        <td class="column0 style5 null"></td>
        <td class="column1 style9 s">Среднее абсолютное отклонение</td>
        <td class="column2 style13 s">Среднеквадратичное отклонение</td>
        <td class="column3 style2 s">Среднее абсолютное отклонение</td>
        <td class="column4 style13 s">Среднеквадратичное отклонение</td>
        <td class="column5 style4 s">Время наложения шума, сек.</td>
      </tr>
      <tr class="row2">
        <td class="column0 style10 s">Параллельный алгоритм</td>
        <td class="column1 style1 n">15.46</td>
        <td class="column2 style1 n">3229.79</td>
        <td class="column3 style1 n">49.21</td>
        <td class="column4 style1 n">11614.51</td>
        <td class="column5 style3 n">1.719</td>
      </tr>
      <tr class="row3">
        <td class="column0 style7 s">Последовательный алгоритм</td>
        <td class="column1 style6 n">15.37</td>
        <td class="column2 style6 n">3212.24</td>
        <td class="column3 style6 n">49.25</td>
        <td class="column4 style6 n">11625.24</td>
        <td class="column5 style5 n">0.257</td>
      </tr>
    </tbody>
</table>

Реализованы алгоритмы наложения импульсного шума с последовательным и параллельным прохождением по каждому пикселю с вероятностью 0,1 изменения его на белый или чёрный цвет. Как видно из таблицы оба алгоритма имеют схождие результаты, но использование параллельного алгоритма с помощью библиотеки numba языка Python для изображения 1280х720 не оправдал ожиданий в производительности в силу переброски данных между устройствой GPU и хостом, несмотря на генерацию случайных чисел внутри устройства. Не исключено, что параллельную реализацию ещё можно улучшить. 

Для восстановления изображения применялся медианный фильтр библиотеки cv2 языка программирования Python, благодаря которому можно избавиться от импульсного шума, но испортить часть данных из-за размытия.


## Изображения

_Исходное изображение_

![Оригинальное изображение](./images/original.jpg)

_Зашумлённое изображение последовательным алгоритмом_

![Зашумлённое изображение](./images/cpu_noise.jpg)

_Зашумлённое изображение параллельным алгоритмом_

![Зашумлённое изображение](./images/gpu_noise.jpg)

_Восстановленное изображение после последовательного зашумления_

![Восстановленное изображение](./images/cpu_result.jpg)

_Восстановленное изображение после параллельным зашумления_

![Восстановленное изображение](./images/gpu_result.jpg)
